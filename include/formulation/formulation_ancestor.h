#ifndef FORMULATION_ANCESTOR_H
#define FORMULATION_ANCESTOR_H

// #include "containers/mat.h"
namespace LMT {
struct SparseUMFPACK;
struct SparseCholMod;


/**
    T est le type de scalaire sur lequel travailler 
 */
template<class ScalarType=double>
class FormulationAncestor {
public:
    typedef typename TypePromote<Abs,ScalarType>::T AbsScalarType;
    struct LinearizedConstraint {
        struct Coeff {
            ScalarType val;
            unsigned num_in_vec;
        };
        Vec<Coeff> coeffs;
        ScalarType val;
    };
    
    FormulationAncestor() {
        assume_constant_matrix = false;
        default_iterative_criterium = ScalarType(0);
        non_linear_iterative_criterium = AbsScalarType(0);
        assume_skin_not_needed = false;
        max_non_linear_iteration = 50;
        premul_KUn_in_sollicitation = ScalarType(1);
        want_amd = false ;
        levenberg_marquadt = AbsScalarType(0);
        max_diag = ScalarType(0);
    }
    virtual ~FormulationAncestor() {}
    
    virtual std::string get_name() const = 0; /// 
    virtual void set_mesh( void *m ) = 0; /// 
    
    virtual bool solve( AbsScalarType iterative_criterium=AbsScalarType(0), bool disp_timing=false ) = 0; ///  The all-in-one procedure -> allocate if necessary, assemble, solve, update_variables, call_after_solve
    virtual bool solve_and_get_derivatives( Vec<Vec<ScalarType> > &der ) = 0;  /// get value and derivative respective to "der_var" defined in SConsruct or in python
    virtual void allocate_matrices() = 0; ///
    virtual void shift(int nb=1) = 0;
    virtual void unshift(int nb=1) = 0;
    virtual unsigned update_connectivity(bool amd=false) =0;
    virtual void assemble(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual bool solve_system(AbsScalarType iterative_criterium=AbsScalarType(0),bool disp_timing=false) = 0;
    virtual Vec<ScalarType> get_nodal_forces() = 0;
    
    virtual void assemble_clean_mat(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual void assemble_constraints(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual void assemble_sollicitations(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual Vec<LinearizedConstraint> get_linearized_constraints() = 0;
    
    virtual void assemble_clean_mat (Mat<ScalarType,Sym<>,SparseLine<> > &K, Vec<ScalarType> &F, Vec<Vec<ScalarType> > &vectors_, const Vec<unsigned> &indice_noda_, bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual void assemble_constraints (Mat<ScalarType,Sym<>,SparseLine<> > &K, Vec<ScalarType> &F, Vec<Vec<ScalarType> > &vectors_, const Vec<unsigned> &local_ddl_to_global_ones, const ScalarType &M, bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual void assemble_sollicitations(Mat<ScalarType,Sym<>,SparseLine<> > &K, Vec<ScalarType> &F, Vec<Vec<ScalarType> > &vectors_, const Vec<unsigned> &local_ddl_to_global_ones, bool assemble_mat=true,bool assemble_vec=true) = 0;

    virtual void get_precond() = 0;
    virtual void solve_system_using_precond(AbsScalarType iterative_criterium) = 0;
    
    virtual void get_factorization_matrix() = 0;
    virtual void solve_system_using_factorization_matrix() = 0;

    virtual void call_after_solve() = 0; ///  call all after_solve in carac elem ( generated by apply_on_elements_after_solve() in formulation_...py )
    virtual void call_after_solve_2() = 0; ///  call all after_solve in carac elem ( generated by apply_on_elements_after_solve_2() in formulation_...py )
    virtual void call_after_solve_3() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )

    virtual void set_vectors_assembly(Vec<Vec<ScalarType> > &vec) = 0;
    virtual void set_indice_noda_assembly(Vec<unsigned> &vec) = 0;
    virtual unsigned get_nb_vectors() = 0; 

    virtual void call_after_solve(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve() in formulation_...py )
    virtual void call_after_solve_2(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_2() in formulation_...py )
    virtual void call_after_solve_3(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )

    virtual void update_variables() = 0; /// update variable at end of the time step
    virtual void update_variables(ScalarType partial_ts) = 0; ///  update variable at time t_n + partial_ts
    virtual void get_initial_conditions() = 0; /// fill vectors[x] using dern_unknown
    virtual void get_initial_conditions(Vec<Vec<ScalarType> > &vectors_,const Vec<unsigned> &indice_noda_) = 0; /// fill vectors[x] using dern_unknown
    
    virtual unsigned get_indice_noda(unsigned num_node) const = 0;
    virtual unsigned num_in_vec_unknown(const std::string &name) const = 0;
    
    /**
     * add a constraint which will be added to system during assembly
     * @param txt constraint in analytic form. Example : "node[0].temperature + time**2 - 10"
     * @param penalty_value constraint will be * by max(abs(diag))*penalty_value
     * @return number of constraint (usefull in order to remove it...)
     */
    virtual unsigned add_constraint(const std::string &txt,const ScalarType &penalty_value) = 0;
    virtual void set_initial_time_step( AbsScalarType ts ) = 0; ///
    virtual ScalarType get_next_time_step() const = 0; ///
    virtual ScalarType get_time() const = 0; ///
    virtual void set_time( AbsScalarType ts ) = 0; /// Attention, pilotage a faire soi-meme si utilisation de cette fonction....
    virtual void clean_mats() = 0; /// 0 in all matrices
    
    virtual unsigned nb_constraints() const = 0;
    virtual void erase_constraints_from(unsigned number) = 0;
    
    virtual unsigned get_nb_nodal_unknowns() const = 0;

    #ifdef WITH_UMFPACK
    virtual void get_mat( Mat<ScalarType,Gen<>,SparseUMFPACK> *&mat ) = 0; ///
    #endif
    virtual void get_mat( Mat<ScalarType,Gen<>,SparseLU> *&mat ) = 0; ///
    #ifdef WITH_CHOLMOD
    virtual void get_mat( Mat<ScalarType,Sym<>,SparseCholMod> *&mat ) = 0; ///
    #endif
    virtual void get_mat( Mat<ScalarType,Sym<>,SparseLine<> > *&mat ) = 0; ///

    virtual void display_mat( std::ostream &os ) const = 0; ///

    virtual void get_der_var_on_mesh( unsigned num_der_var ) = 0;
    
    virtual Vec<ScalarType> &get_sollicitation() = 0; ///
    virtual Vec<ScalarType> &get_result(unsigned num=0) = 0; ///

    bool assume_constant_matrix; ///
    ScalarType default_iterative_criterium; /// iterative_criterium for conjugate gradient, GMRES, ... based on norm_inf( delta solution )
    AbsScalarType non_linear_iterative_criterium; /// iterative_criterium for newton-raphson iterations, ... based on norm_inf( delta solution )
    Vec<AbsScalarType> non_linear_iterative_criterium_vec; /// iterative_criterium for newton-raphson iterations, ... based on norm_inf( delta solution )
    unsigned order_integration_when_integration_totale;
    bool assume_skin_not_needed;
    unsigned max_non_linear_iteration;
    ScalarType premul_KUn_in_sollicitation;
    bool want_amd;
    AbsScalarType levenberg_marquadt; /// K += levenberg_marquadt * max( abs( K ) ) * Id; 0 by default
    ScalarType max_diag;
};

}

#endif // FORMULATION_ANCESTOR_H
