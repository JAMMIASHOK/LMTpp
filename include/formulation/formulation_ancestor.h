#ifndef FORMULATION_ANCESTOR_H
#define FORMULATION_ANCESTOR_H

// #include "containers/mat.h"
namespace LMT {
struct SparseUMFPACK;
struct SparseCholMod;


/**
    T est le type de scalaire sur lequel travailler 
 */
template<class ScalarType=double>
class FormulationAncestor {
public:
    struct LinearizedConstraint {
        struct Coeff {
            ScalarType val;
            unsigned num_in_vec;
        };
        Vec<Coeff> coeffs;
        ScalarType val;
    };
    
    FormulationAncestor() {
        assume_constant_matrix = false;
        default_iterative_criterium = 0.0;
        assume_skin_not_needed = false;
    }
    virtual ~FormulationAncestor() {}
    
    virtual std::string get_name() const = 0; /// 
    virtual void set_mesh( void *m ) = 0; /// 
    
    virtual bool solve(ScalarType iterative_criterium=0.0,bool disp_timing=false,bool want_amd=false) = 0; ///  The all-in-one procedure -> allocate if necessary, assemble, solve, update_variables, call_after_solve
    virtual void allocate_matrices(bool amd=false) = 0; ///
    virtual void shift(int nb=1) = 0;
    virtual void unshift(int nb=1) = 0;
    virtual void assemble(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual bool solve_system(ScalarType iterative_criterium=0.0,bool disp_timing=false) = 0;
    
    virtual void assemble_clean_mat(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual void assemble_constraints(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual void assemble_sollicitations(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual Vec<LinearizedConstraint> get_linearized_constraints() = 0;
    
    virtual void get_precond() = 0;
    virtual void solve_system_using_precond(ScalarType iterative_criterium) = 0;
    
    virtual void get_factorization_matrix() = 0;
    virtual void solve_system_using_factorization_matrix() = 0;

    virtual void call_after_solve() = 0; ///  call all after_solve in carac elem ( generated by apply_on_elements_after_solve() in formulation_...py )
    virtual void call_after_solve_2() = 0; ///  call all after_solve in carac elem ( generated by apply_on_elements_after_solve_2() in formulation_...py )
    virtual void call_after_solve_3() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )

    virtual void call_after_solve(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve() in formulation_...py )
    virtual void call_after_solve_2(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_2() in formulation_...py )
    virtual void call_after_solve_3(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )

    virtual void update_variables() = 0; /// update variable at end of the time step
    virtual void update_variables(ScalarType partial_ts) = 0; ///  update variable at time t_n + partial_ts
    virtual void get_initial_conditions() = 0; /// fill vectors[x] using dern_unknown
    
    virtual unsigned get_indice_noda(unsigned num_node) const = 0;
    
    /**
     * add a constraint which will be added to system during assembly
     * @param txt constraint in analytic form. Example : "node[0].temperature + time**2 - 10"
     * @param penalty_value constraint will be * by max(abs(diag))*penalty_value
     * @return number of constraint (usefull in order to remove it...)
     */
    virtual unsigned add_constraint(const std::string &txt,const ScalarType &penalty_value) = 0;
    virtual void set_initial_time_step( ScalarType ts ) = 0; ///
    virtual ScalarType get_next_time_step() const = 0; ///
    virtual ScalarType get_time() const = 0; ///
    virtual void set_time( ScalarType ts ) = 0; /// Attention, pilotage a faire soi-meme si utilisation de cette fonction....
    
    virtual unsigned nb_constraints() const = 0;
    virtual void erase_constraints_from(unsigned number) = 0;

    #ifdef WITH_UMFPACK
    virtual void get_mat( Mat<ScalarType,Gen<>,SparseUMFPACK> *&mat ) = 0; ///
    #endif
    virtual void get_mat( Mat<ScalarType,Gen<>,SparseLU> *&mat ) = 0; ///
    #ifdef WITH_CHOLMOD
    virtual void get_mat( Mat<ScalarType,Sym<>,SparseCholMod> *&mat ) = 0; ///
    #endif
    virtual void get_mat( Mat<ScalarType,Sym<>,SparseLine<> > *&mat ) = 0; ///

    virtual Vec<ScalarType> &get_sollicitation() = 0; ///
    virtual Vec<ScalarType> &get_result(unsigned num=0) = 0; ///

    bool assume_constant_matrix; ///
    ScalarType default_iterative_criterium; ///
    unsigned order_integration_when_integration_totale;
    bool assume_skin_not_needed;
};

}

#endif // FORMULATION_ANCESTOR_H
