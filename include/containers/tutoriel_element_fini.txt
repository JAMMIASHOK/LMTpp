/*!
\tutorial Comment résoudre un problème éléments finis de façon générale

    La résolution d'un problème avec les éléments finis se fait en trois étapes :
        * Création d'un fichier python .py qui contiendra le nom du problème, les propriétés physiques générales du système et le type d'éléments finis.
        * Création d'un autre fichier python pour la formulation (i.e. les équations, les granduers inconnues, les paramètres, ...)
        * Création d'un projet kdevelop pour d'une part générer les fichiers d'en-têtes C++ .h à partir des deux précédents fichiers python puis d'autre part pour écrire le code de calcul.


    = Creation d'un fichier "problem.h.py"

        Ce fichier sert à la fois a la definition du maillage (type d'element, dimension avec variables stockees) et des formulations retenues

        Exemple de fichier

        \code Python
            from LMT.formal_lf import *
            import string
   
            write_pb(
                name = 'pb_elast',
                incpaths=['FORMULATIONS','LMT/formulations'],
                formulations = ['elasticity_isotropy','elasticity_orthotropy'],
                elements = ['Triangle','Tetra'],
                dim = 3
                additional_fields = {
                    "qtrans" : Variable(unit='mm',nb_dim=['DIM']),
                    #"qtrans" : Variable(unit='mm',T='Vec<double,DIM>'),
                    "typmat" : Variable(interpolation='elementary',unit='',default_value='0'),
                }
                options = {
                    "behavior_simplification" : 'plane stress'   
                }
            )
        Remarque: les commentaires python sur une ligne commencent par un diese (#).
        Détail des champs :
        * <strong> name </strong> : pb_elast est le nom donné au problème. Pour déclarer ensuite un maillage il faudra faire 
            \code C/C++
                Mesh<Meshcarac_pb_elast<type, dim> > m; // où type est le type des variables (float, double, long double, etc) et dim la dimension de l'espace
        * <strong> incpaths </strong> : (optionnel ) contient les chemins dans lesquels les fichiers de formulations doivent etre recherchés.
        * <strong> formulations </strong> contiens les noms des formulations sur lesquelles on veut travailler. Dans les repertoires indiqués dans incpaths, doivent se trouver des fichiers python nommés formulation_elasticity_isotropy.py, formulation_elasticity_orthotropy.py. Ces fichiers contiennent les variables utilisées pour la formulation (modules materiau, contrainte, deplacement,deformation, energie..). C'est à l'interieur de ce fichier que l'on ecrit directement la formulation sous forme variationnelle (cf ci-dessous).
   
        * <strong> elements </strong> contient les types d'éléments à utiliser dans le maillage parmi : Bar, Triangle, Quad, Tetra, Wedge, Cube, etc ... 
        * <strong> dim (optionnel) </strong> est la dimension pour tous les éléments précédemment définis.  Par defaut dim = 'nvi', c'est à dire que tous les éléments sont regroupés selon leur nombre de variables d'interpolation (2 pour les quad et triangle, 3 pour tetra, cube, wedge, 1 pour les bar). Il est possible d'imposer a dim n'importe quelle expression basée sur nvi.
        * <strong> additional_fields </strong> contient les champs additionnels à placer dans les maillages suivant la syntaxe
             "nom du champs" : Variable (interpolation=valeur, unit=valeur,default_value=valeur,T=valeur,nb_dim=tableau de valeurs) où les valeurs sont exprimées sous forme d'un chaine de caractères. 
            * <strong> interpolation </strong> : correspond au type d'interpolation de la variable, choisi parmi : nodal, elementary, global, der_nodal (dérivable d'un champ nodal, vecteur contenant n points de gauss eux meme contenant de qu'on veut),bubble, etc ... Pour connaître l'ensemble des possibilités, consultez la rubrique Maillage/Interpolation de la page "mot-clés".
            * <strong> unit </strong> est l'unité du champs.
            * <strong> default_value </strong> est la valeur par defaut.
            * <strong> T </strong> ='type' si on souhaite donner un type special. Par exemple si un champ dépend de la dimension du problème, on écrira T='Vec<double,dim>' . 
            * <strong> nb_dim </strong> est la dimension du champ si le champs est un vecteur.
            * <strong> options </strong> est un comportement comme par exemple "behavior_simplification", 'plane stress', 'axysymmetric', 'plane strain'  ...

    = Création d'un fichier de formulation "formulation_elasticity.py"
           = Exemple de fichier
               \code Python
                f_vol = Variable( interpolation='global', nb_dim=[dim], default_value='0.0,'*(dim-1)+'0.0', unit='N/m^3' )
                elastic_modulus = Variable( interpolation='global', default_value='15e3', unit='N/mm^2' )
                poisson_ratio = Variable( interpolation='global', default_value='0.3', unit='1' )
                density = Variable( interpolation='global', default_value='1', unit='kg/mm^3' )
    
                dep = Variable( unknown=True, nb_dim=[dim], default_value='0.0', unit='mm' )
    
                sigma = Variable( interpolation='der_nodal', default_value='0', nb_dim=[dim*(dim+1)/2], unit='N/mm^2' )
                epsilon = Variable( interpolation='der_nodal', default_value='0', nb_dim=[dim*(dim+1)/2], unit='' )
                ener = Variable( interpolation='elementary', default_value='0', unit='N*mm' )
    
    
                def formulation():
                    epsilon = grad_sym_col(dep.expr)
                    epstest = grad_sym_col(dep.test)
                    behavior_simplification=options["behavior_simplification"]
                    sigma = mul( hooke_matrix(elastic_modulus.expr,poisson_ratio.expr,dim,behavior_simplification) ,epsilon )
    
                    res = density.expr * dot( dep.expr.diff(time).diff(time) - f_vol.expr, dep.test )
                    for i in range(dim): res += sigma[i] * epstest[i]
                    for i in range(dim,epsilon.size()): res += 2 * sigma[i] * epstest[i]
    
                    return res * dV
    
                def apply_on_elements_after_solve(unk_subs): # return a string
                    H = hooke_matrix(elastic_modulus.expr,poisson_ratio.expr,dim,'plane stress')
                    epsilon = grad_sym_col(dep.expr)
                    sigma = mul( H, epsilon )
                    #my_subs = unk_subs
                    #my_subs[ time ] = time_steps[0]
                    #for vi in e.var_inter: my_subs[vi] = number(0.5)
                    #sigma = sigma.subs(EM(my_subs))
                    #epsilon = epsilon.subs(EM(my_subs))
        
                    cw = Write_code('T')
                    for i in range(dim*(dim+1)/2):
                        cw.add( epsilon[i], 'elem.epsilon[0]['+str(i)+']', Write_code.Set )
                        cw.add( sigma[i], 'elem.sigma[0]['+str(i)+']', Write_code.Set )
                    return cw.to_string()

            Expliquons le code      
            = Première étape : définition des variables accessibles au niveau du maillage   
                C'est la même syntaxe que celle du premier fichier python avec un nouveau champ facultatif, unknown,  champs spécial indiquant que la variable est une inconnue du problème (obtenue par résolution d'un systeme).
            = Deuxième étape : définition de la formulation.
                On ecrit la formulation sous forme variationnelle dans la fonction formulation(). On aura bien-sûr besoin des champs et d'opérateurs classiques.
                pour accéder à un champ C défini dans la première étape, on écrit C.expr et les opérateurs implémentés sont :
                    * grad_sym_col
                    * green_lagrange
                    * pos
                    * analytical_integration
                    * integration
                    * jacobian
                    * inverse_jacobian
                    * det_jacobian
                    * grad
                    * grad_sym
                    * green_lagrange_col
                    * div
                Pour être au courant des derniers ajouts, consulter le fichier "element.py".

                pour definir une variable de type symbole : E = symbol('m.elastic_modulus')
                pour definir un vecteur : vect = vector([...])
                pour definir une matrice : mat = matrice([ [...] , [...] ])
                pour multiplier une matrice par un vecteur : mul(mat,vect)
                pour inverser une matrice mat.inverse()
    
                les matrices de hooke sont definies dans material_help.py
    
                On doit renvoyer l'expression variationnelle complete sans s'oocuper de savoir si on obtient une matrice ou un vecteur en sortie dV, dS ... correspond a l'integration souhaitee
   
            = Troisième étape : définition de fonctions pour calculer des valeurs apres résolution
                possibilite d'ecrire jusqu'a 3 fonctions (apply_on_elements_after_solve, apply_on_elements_after_solve_2, apply_on_elements_after_solve_3).
                Pour écrire le code généré, on utilise 
                \code Python
                    cw.Write_code(type,nombre d'espace dans le code genere)
                pour ajouter un champ 
                \code Python 
                    cw.add(valeur, 'expression en cpp', Write_code.Set)  (ou Write_code.Add )
                pour écrire le code
                \code Python 
                    return cw.to_string()
    
                <strong> Attention : </strong> il n'est possible d'ecrire des variables que composante par composante
   
    = Projet Kdevelop

        Si vous avez oubliez comment on procède pour créer un projet kdevelop, consulter le tutoriel \a "Mon premier programme" .
   
        = Utilisation en C++ des maillages et formulations

            = Définition d'un maillage caractérisé  par les deux fichiers problem.h.py, formulation_elasticity.py
                \code C/C++
                    typedef Mesh<Mesh_carac_pb_elas<double,2 > > TM;
                    TM m;
    
            = Pour accéder aux champs definis au maillage :
                * champs globaux : m.elastic_modulus
                * champs nodaux : m.node_list[i].dep  
                * champs aux elements : créer un opérateur pour réaliser l'operation escomptée (exemple, affichage d'un champ particulier)
                \code C/C++
                    struct affich_sigma{
                        template<class TE> void operator()(TE &e) const{
                        cout<< e.sigma[0] << endl;  // affichage de la contrainte au point de gauss 0
                        }
                    };
    
            = Définition d'une formulation
                \code C/C++
                    typedef Formulation<TM,elasticity> TF;
                    TF f(m);
    
                Remarque : f.m fait référence au maillage de la formulation.

    Allez voir les pages de :
    \relates Mesh
    \relates MeshCarac

    \friend hugo.leclerc@lmt.ens-cachan.fr
    \friend raphael.pasquier@lmt.ens-cachan.fr
*/ 