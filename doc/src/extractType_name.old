void PageComment :: extract_returnType_name( int* suivant, Names& returnType, Names& name, string& t ,int end, int start ) {

    deque<int> localListIndex ;
    string localtype ;
    string localname ;
    int n,next,i ;
    char delim,c,cnext ;


    extract_list_lexem( &next,localListIndex,&delim,"(",t,end,start ) ;

    // normalement delim == (
    n = localListIndex.size() - 4 ;
    while(n >= 0) {
        c = t[localListIndex[n]] ;
        cnext = t[localListIndex[n+1]] ;
        //cout << " c ===== " << c << endl ;
        //cout << " cnext ===== " << cnext << endl ;
        //cout << " lexem = " << t.substr(localListIndex[n],localListIndex[n+1]-localListIndex[n]) << endl ;
        if ((c == '&') || (c == '*')) { break ; }
        if (cnext == ' ') { break ; }
        n -= 2 ;
    }
    //cout << " n = " << n << endl ;
    for(i=0;i<=n; i += 2) {
        if (i<n)
            localtype += t.substr( localListIndex[i], localListIndex[i+1] - localListIndex[i] ) + ' ' ;
        else
            localtype += t.substr( localListIndex[i], localListIndex[i+1] - localListIndex[i] ) ;
    }
    //if (localtype.size()>0) localtype.erase(localtype.size()-1) ;

    for(i=n+2;i<localListIndex.size(); i += 2) {
        if (i<localListIndex.size()-2)
            localname += t.substr( localListIndex[i], localListIndex[i+1] - localListIndex[i] ) + ' ' ;
        else
            localname += t.substr( localListIndex[i], localListIndex[i+1] - localListIndex[i] ) ;
    }

    // il faut traiter le cas particulier de l'opÃ©rateur operator()
    if (localname == "operator") {
        localname += "()" ;
        extract_list_lexem( &next,localListIndex,&delim,"(",t,end,next ) ;
    }
    //cout << "RETURN TYPE == " << localtype << endl ;
    //cout << "NAME OF FUNCTION == " << localname << endl ;
    returnType.name = localtype ;
    returnType.principalName = principal_type_of( localtype ) ;
    name.name = localname ;
    name.principalName = principal_type_of( localname ) ;
    *suivant = next ;
}