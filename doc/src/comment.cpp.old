#include <iostream>
#include <string>
#include <vector>


using namespace std ;
#include "token.h"
#include "op.h"
#include "comment.h"
#include "commentitem.h"
#include "commentitemkeyword.h"
#include "commentitemtxt.h"
#include "commentitemcode.h"
#include "commentitemsection.h"
#include "commentitemtable.h"
#include "commentitemlist.h"
#include "commentitemwebpage.h"

#define SIZE_TABLE_KEYWORD 19

// i.e. dans le tableau ci-dessous à partir de brief ce sont des mot-clés qui caractérisent le commentaire
#define INDEX_CARACTERISTIC 8
//#define INDEX_CARACTERISTIC_TXT 15
#define INDEX_TO 18

char* Comment::keyword[SIZE_TABLE_KEYWORD] = {
                                         "a",
                                         "class",
                                         "struct",
                                         "fn",
                                         "enum",
                                         "m",
                                         "example",
                                         "tutorial",
                                         "brief", // 8
                                         "property",
                                         "mainclass",
                                         "incategory",
                                         "param",
                                         "return",
                                         "member",
                                         "code",  // 15
                                         "table",
                                         "webpage", // 17
                                         "to", // 18
                                     } ;


// ----------------------------------------------------
struct LangRef {
    virtual void print( std::ostream &os ) const = 0;
    virtual ~LangRef() {}
}
;

struct LangRefFunction : public LangRef {
    virtual void print( std::ostream &os ) const {}
    virtual ~LangRefFunction() {}
}
;

Comment :: ~Comment() {
 int i,l ;
 
 l = items.size() ;
 for(i=0;i<l;i++) delete items[i] ;
}

void Comment :: addCommentItem( CommentItem*  c ) {
    items.push_back( c ) ;
}


void Comment :: apply_on_related_to( const std::string &s, Op *op ) {

    // for(unsigned i=0;i<items.size();++i)
    //            items[i]->apply_on_related_to( s, op );
}

string Comment::findKeyword( int* t,int* position,int* positionAfter, string& s) {

    string token ;
    int pos,pos2,j ;
    
    j = -10 ;
    pos = -10 ;
    pos2 = -10 ;
    if (chercher_motif( s,"\\",&pos,s.size() )) {
        token = extraire_token( &pos2,s,pos+1 ) ;// après l'appel pos2 pointe sur le caractère qui suit le token
        for(j=0;j<SIZE_TABLE_KEYWORD;j++) 
            if (token == Comment::keyword[j]) break ;
    }
    *t = j ;
    *position = pos ;
    *positionAfter = pos2 ;
    return token ;
}

void Comment :: parse( vector<string>& file ) {

    int n,i,pos,j,c,nb_espaces_reference,pos2,nb ;
    string token ;
    string token2 ;
    CommentItemKeyword* ptr_CommentItemKeyword ;
    CommentItemTxt*     ptr_CommentItemTxt ;
    CommentItemCode*    ptr_CommentItemCode ;
    CommentItemSection* ptr_CommentItemSection ;
    CommentItemTable*   ptr_CommentItemTable ;
    CommentItemList*    ptr_CommentItemList ;
    CommentItemWebPage* ptr_CommentItemWebPage ;
    char caractere ;

    //type = -1 ;
    i=0 ;
    n = file.size() ;
    //cout << "===================================================" << endl ;
    //for(i=0;i<n;i++) cout << file[i] << endl ;
    //cout << "===================================================" << endl ;
    //i = 0 ;

    while(i<n) {
        token = findKeyword(&j,&pos,&pos2,file[i] ) ; //après l'appel pos contient l'indice du premier caractère du mot clé et pos2 celui du premier caractère après le token
        //cout << "--token =" << token << "|___" << endl ;
        //cout << "--pos = " << pos << endl ;
        //cout << "--pos2 = " << pos2 << endl ;
        //cout << "--j = " << j << endl ;
        switch(j) {
            case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : case 8 : case 9 : case 10 : case 11 : case 12 : case 13 : case 14 :
                ptr_CommentItemKeyword = new CommentItemKeyword( token ) ;
                addCommentItem( ptr_CommentItemKeyword ) ;
                token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ;
                ptr_CommentItemKeyword->addParameter( token2 ) ;
                //if (j<INDEX_CARACTERISTIC) type = j ;
                i++ ;
                break ;

            case 15 : // pour un code
                token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ; // récupération du langage
                ptr_CommentItemCode = new CommentItemCode( token2) ;
                addCommentItem( ptr_CommentItemCode ) ;
                i++ ;
                nb_espaces_reference = 0 ;
                while (i<n)  {
                    c = compter_caractere( &pos2,file[i], ' ' ) - pos ; // pos contient la position de \code
                    if (c <= 1) break ; // problème potentiel --- pour distinguer la fin d'un code
                    if (nb_espaces_reference == 0) nb_espaces_reference = c ; 
                    token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ;
                    ptr_CommentItemCode->addTabulation_String( c/nb_espaces_reference, token2) ;
                    i++ ;
                }
                break ;

            case 16 : // pour un tableau
                token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ; // récupération du header
                ptr_CommentItemTable = new CommentItemTable( token2 ) ;
                addCommentItem( ptr_CommentItemTable ) ;
                i++ ;
                nb_espaces_reference = 0 ;
                while (i<n)  {
                    c = compter_caractere( &pos2,file[i], ' ' ) - pos ; // pos contient la position de \table
                    if (nb_espaces_reference == 0) nb_espaces_reference = c ; 
                    if ( (c <= 1) || (c < nb_espaces_reference)) break ;// problème potentiel pour distinguer la fin d'un tableau
                    token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ;
                    ptr_CommentItemTable->addLine( token2 ) ;
                    i++ ;
                }
                break ;

            case 17 : // pour une page web
                token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ; // récupération des paramètres
                //cout << "++++++++++++++++++++++  token web page +++++++++++++++++++++++" << endl ;
                //cout << " token2 page web =" << token2 << "|||" << endl ;
                ptr_CommentItemWebPage = new CommentItemWebPage( token2 ) ;
                addCommentItem( ptr_CommentItemWebPage ) ;
                i++ ;
                break ;

            case INDEX_TO : // c'est un \to donc on ne fait rien !!!
                break ;

            case SIZE_TABLE_KEYWORD : // token inconnu
                //cout << "--------------------  token inconnu ---------------------" << endl ;
                //cout << " token =" << token << "|||" << endl ;
                //cout << " j=" << j << endl ;
                ptr_CommentItemTxt = new CommentItemTxt() ;
                addCommentItem( ptr_CommentItemTxt ) ;
                ptr_CommentItemTxt->addString( file[i] ) ;
                i++ ;
                //while ((i<n) && (!chercher_motif( file[i],"\\",&pos )) && (! chercher_liste(&pos,&caractere,file[i])) && (! chercher_section(&pos,file[i])) ){
                //    ptr_CommentItemTxt->addString( file[i] ) ;
                //    i++ ;
                //}
                break ;

            default : // pas de token
                      // c'est du texte ou une section ou bien une liste
                    if ( chercher_section(&pos,file[i]) ) { // c'est un titre de section
                        //cout << "--------- SECTION -------------" << endl ;
                        token = file[i].substr(pos+1,file[i].size()-pos ) ;
                        ptr_CommentItemSection = new CommentItemSection( token,pos ) ;
                        addCommentItem( ptr_CommentItemSection ) ;
                        i++ ;
                    }
                    else {
                        if (chercher_liste(&pos,&caractere,file[i])) {// c'est une liste
                            //cout << "--------- liste -------------" << endl ;
                            token = file[i].substr(pos+1,file[i].size()-pos ) ;
                            ptr_CommentItemList = new CommentItemList( ) ;
                            addCommentItem( ptr_CommentItemList ) ;
                            ptr_CommentItemList->addCaracteristic( token,pos,caractere ) ;
                            i++ ;
                            while ((i<n) && (chercher_liste(&pos,&caractere,file[i]))) {
                                token = file[i].substr(pos+1,file[i].size()-pos ) ;
                                ptr_CommentItemList->addCaracteristic( token,pos,caractere ) ;
                                i++ ;
                            }
                        }
                        else {// c'est du simple texte
                            ptr_CommentItemTxt = new CommentItemTxt() ;
                            addCommentItem( ptr_CommentItemTxt ) ;
                            ptr_CommentItemTxt->addString( file[i] ) ;
                            i++ ;
                            while ((i<n) && (! chercher_liste(&pos,&caractere,file[i])) && (! chercher_section(&pos,file[i])) ){
                                token = findKeyword(&j,&pos,&pos2,file[i] ) ;
                                //cout << " file[" << i << "]=" << file[i] << endl ;
                                //cout << "==token =" << token << "|___" << endl ;
                                if ((j>=0) && (j<INDEX_TO)) break ;
                                ptr_CommentItemTxt->addString( file[i] ) ;
                                i++ ;
                            }
                        }
                    }
        }
    }
}

// ----------------------------------------------------
std::ostream &operator<<( std::ostream &os, const Comment &c ) {
    int n = c.items.size() ;
    //os << "type de Comment = " << c.type << endl ;
    for(int i=0;i<n;++i) os << *c.items[i] << endl ;
    os << " fin de comment" << endl ; 
    return os;
}

void Comment :: generateHTML( string& name ){

    int i ;
    int n = items.size() ;


    for(int i=0;i<n;++i) { 
        // items[i].generateHTML( name) ;
    }
}



