
void Comment :: parse( vector<string>& file ) {

    int n,i,pos,j,c,nb_espaces_reference,pos2,nb ;
    string token ;
    string token2 ;
    CommentItemKeyword* ptr_CommentItemKeyword ;
    CommentItemTxt* ptr_CommentItemTxt ;
    CommentItemCode* ptr_CommentItemCode ;
    CommentItemSection* ptr_CommentItemSection ;
    CommentItemTable* ptr_CommentItemTable ;
    CommentItemList* ptr_CommentItemList ;
    CommentItemWebPage* ptr_CommentItemWebPage ;
    char caractere ;

    type = 0 ;
    i=0 ;
    n = file.size() ;

while(i<n) {
    if (chercher_motif( file[i],"\\",&pos )) {
        token = extraire_token( &pos2,file[i],pos+1 ) ;// après l'appel pos pointe sur le caractère qui suit le token
        //cout << " tOKEN =" << token << "|" << endl ;
        for(j=0;j<INDEX_ALMOST_EVERYWHERE;j++) 
            if (token == keyword[j]) break ;
        if (j<INDEX_CARACTERISTIC_TXT) {
            // créer un CommentCommentItemKeyword
            ptr_CommentItemKeyword = new CommentItemKeyword( token ) ;
            addCommentItem( ptr_CommentItemKeyword ) ;
            token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ;
            ptr_CommentItemKeyword->addParameter( token2 ) ;
            if (j<INDEX_CARACTERISTIC) type = j +1 ;
            i++ ;
        }
        else {
            if (j<INDEX_ALMOST_EVERYWHERE) {// c'est un token pour le texte

                switch(j) {
                    case INDEX_CARACTERISTIC_TXT : // pour un code
                            token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ; // récupération du langage
                            ptr_CommentItemCode = new CommentItemCode( token2) ;
                            addCommentItem( ptr_CommentItemCode ) ;
                            i++ ;
                            nb_espaces_reference = 0 ;
                            while (i<n)  {
                                c = compter_caractere( &pos2,file[i], ' ' ) - pos ; // pos contient la position de \code
                                if (c <= 1) break ; // problème potentiel --- pour distinguer la fin d'un code
                                if (nb_espaces_reference == 0) nb_espaces_reference = c ; 
                                token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ;
                                ptr_CommentItemCode->addTabulation_String( c/nb_espaces_reference, token2) ;
                                i++ ;
                            }
                            break ;
                    case INDEX_CARACTERISTIC_TXT + 1 : // pour un tableau
                            token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ; // récupération du header
                            ptr_CommentItemTable = new CommentItemTable( token2 ) ;
                            addCommentItem( ptr_CommentItemTable ) ;
                            i++ ;
                            nb_espaces_reference = 0 ;
                                while (i<n)  {
                                c = compter_caractere( &pos2,file[i], ' ' ) - pos ; // pos contient la position de \table
                                if (nb_espaces_reference == 0) nb_espaces_reference = c ; 
                                if ( (c <= 1) || (c < nb_espaces_reference)) break ;// problème potentiel pour distinguer la fin d'un tableau
                                token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ;
                                ptr_CommentItemTable->addLine( token2 ) ;
                                i++ ;
                            }
                            break ;
                    case INDEX_CARACTERISTIC_TXT + 2 : // pour une page web
                            token2 = file[i].substr(pos2,file[i].size()-pos2+1 ) ; // récupération des paramètres
                            //cout << "++++++++++++++++++++++  token web page +++++++++++++++++++++++" << endl ;
                            //cout << " token2 page web =" << token2 << "|||" << endl ;
                            ptr_CommentItemWebPage = new CommentItemWebPage( token2 ) ;
                            addCommentItem( ptr_CommentItemWebPage ) ;
                            i++ ;
                            break ;
                }
            }
            else { // token inconnu
            cout << "--------------------  token inconnu ---------------------" << endl ;
            cout << " token =" << token << "|||" << endl ;
            cout << " j=" << j << endl ;
            ptr_CommentItemTxt = new CommentItemTxt() ;
            addCommentItem( ptr_CommentItemTxt ) ;
            ptr_CommentItemTxt->addString( file[i] ) ;
            i++ ;
            while ((i<n) && (!chercher_motif( file[i],"\\",&pos )) && (! chercher_liste(&pos,&caractere,file[i])) && (! chercher_section(&pos,file[i])) ){
                ptr_CommentItemTxt->addString( file[i] ) ;
                i++ ;
            }
            }
        }
    }
    else { // c'est du texte ou une section ou bien une liste

    if ( chercher_section(&pos,file[i]) ) { // c'est un titre de section
        //cout << "--------- SECTION -------------" << endl ;
        token = file[i].substr(pos+1,file[i].size()-pos ) ;
        ptr_CommentItemSection = new CommentItemSection( token,pos ) ;
        addCommentItem( ptr_CommentItemSection ) ;
        i++ ;
    }
    else {
        if (chercher_liste(&pos,&caractere,file[i])) {// c'est une liste
            //cout << "--------- liste -------------" << endl ;
            token = file[i].substr(pos+1,file[i].size()-pos ) ;
            ptr_CommentItemList = new CommentItemList( ) ;
            addCommentItem( ptr_CommentItemList ) ;
            ptr_CommentItemList->addCaracteristic( token,pos,caractere ) ;
            i++ ;
            while ((i<n) && (chercher_liste(&pos,&caractere,file[i]))) {
                token = file[i].substr(pos+1,file[i].size()-pos ) ;
                ptr_CommentItemList->addCaracteristic( token,pos,caractere ) ;
                i++ ;
            }
        }
        else {// c'est du simple texte
            ptr_CommentItemTxt = new CommentItemTxt() ;
            addCommentItem( ptr_CommentItemTxt ) ;
            ptr_CommentItemTxt->addString( file[i] ) ;
            i++ ;
            while ((i<n) && (!chercher_motif( file[i],"\\",&pos )) && (! chercher_liste(&pos,&caractere,file[i])) && (! chercher_section(&pos,file[i])) ){
                ptr_CommentItemTxt->addString( file[i] ) ;
                i++ ;
            }
        }
    }
    }
 }
}

// ----------------------------------------------------
std::ostream &operator<<( std::ostream &os, const Comment &c ) {
    int n = c.items.size() ;
    os << "type de Comment = " << c.type << endl ;
    for(int i=0;i<n;++i) os << *c.items[i] << endl ;
    os << " fin de comment" << endl ; 
    return os;
}