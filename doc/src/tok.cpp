#include "tok.h"

namespace Tok {

void disp(std::ostream &os,const void *tok) {
    switch ( *reinterpret_cast<const unsigned *>(tok) ) {
        case END_TOK_FILE: os << "END_TOK_FILE"; break;
        case PUSH_ROOM_FOR_NEW_VARIABLE: os << "PUSH_ROOM_FOR_NEW_VARIABLE"; break;
        case CHECK_ROOM_IN_VARIABLE_STACK: os << "CHECK_ROOM_IN_VARIABLE_STACK"; { const Tok::Check_room_in_variable_stack *d = reinterpret_cast<const Tok::Check_room_in_variable_stack *>( tok ); os << " nb_variables=" << (d->nb_variables); }  break;
        case VARIABLE_NAMED: os << "VARIABLE_NAMED"; { const Tok::Variable_named *d = reinterpret_cast<const Tok::Variable_named *>( tok ); os << " name=" << (d->name); }  break;
        case VARIABLE_IN_STACK: os << "VARIABLE_IN_STACK"; { const Tok::Variable_in_stack *d = reinterpret_cast<const Tok::Variable_in_stack *>( tok ); os << " offset_in_nb_variables=" << (d->offset_in_nb_variables); }  break;
        case VARIABLE_IN_ARGS: os << "VARIABLE_IN_ARGS"; { const Tok::Variable_in_args *d = reinterpret_cast<const Tok::Variable_in_args *>( tok ); os << " num_arg=" << (d->num_arg); }  break;
        case GET_ATTR: os << "GET_ATTR"; { const Tok::Get_attr *d = reinterpret_cast<const Tok::Get_attr *>( tok ); os << " name=" << (d->name); }  break;
        case SELF: os << "SELF"; break;
        case INTERACT: os << "INTERACT"; break;
        case CONSTIFY: os << "CONSTIFY"; break;
        case ASSIGN__CALCULATED_NAME_0__TYPE_0__NEED_VERIFICATION_0: os << "ASSIGN__CALCULATED_NAME_0__TYPE_0__NEED_VERIFICATION_0"; { const Tok::Assign *d = reinterpret_cast<const Tok::Assign *>( tok ); os << " static=" << bool(d->attributes&1); os << " const=" << bool(d->attributes&2); os << " virtual=" << bool(d->attributes&4); os << " want_ref=" << bool(d->attributes&8); os << " property=" << bool(d->attributes&16); os << " offset_to_doc=" << (d->offset_to_doc); os << " name=" << (d->name); }  break;
        case ASSIGN__CALCULATED_NAME_1__TYPE_0__NEED_VERIFICATION_0: os << "ASSIGN__CALCULATED_NAME_1__TYPE_0__NEED_VERIFICATION_0"; { const Tok::Assign *d = reinterpret_cast<const Tok::Assign *>( tok ); os << " static=" << bool(d->attributes&1); os << " const=" << bool(d->attributes&2); os << " virtual=" << bool(d->attributes&4); os << " want_ref=" << bool(d->attributes&8); os << " property=" << bool(d->attributes&16); os << " offset_to_doc=" << (d->offset_to_doc); os << " name=" << (d->name); }  break;
        case ASSIGN__CALCULATED_NAME_0__TYPE_1__NEED_VERIFICATION_0: os << "ASSIGN__CALCULATED_NAME_0__TYPE_1__NEED_VERIFICATION_0"; { const Tok::Assign *d = reinterpret_cast<const Tok::Assign *>( tok ); os << " static=" << bool(d->attributes&1); os << " const=" << bool(d->attributes&2); os << " virtual=" << bool(d->attributes&4); os << " want_ref=" << bool(d->attributes&8); os << " property=" << bool(d->attributes&16); os << " offset_to_doc=" << (d->offset_to_doc); os << " name=" << (d->name); }  break;
        case ASSIGN__CALCULATED_NAME_1__TYPE_1__NEED_VERIFICATION_0: os << "ASSIGN__CALCULATED_NAME_1__TYPE_1__NEED_VERIFICATION_0"; { const Tok::Assign *d = reinterpret_cast<const Tok::Assign *>( tok ); os << " static=" << bool(d->attributes&1); os << " const=" << bool(d->attributes&2); os << " virtual=" << bool(d->attributes&4); os << " want_ref=" << bool(d->attributes&8); os << " property=" << bool(d->attributes&16); os << " offset_to_doc=" << (d->offset_to_doc); os << " name=" << (d->name); }  break;
        case ASSIGN__CALCULATED_NAME_0__TYPE_0__NEED_VERIFICATION_1: os << "ASSIGN__CALCULATED_NAME_0__TYPE_0__NEED_VERIFICATION_1"; { const Tok::Assign *d = reinterpret_cast<const Tok::Assign *>( tok ); os << " static=" << bool(d->attributes&1); os << " const=" << bool(d->attributes&2); os << " virtual=" << bool(d->attributes&4); os << " want_ref=" << bool(d->attributes&8); os << " property=" << bool(d->attributes&16); os << " offset_to_doc=" << (d->offset_to_doc); os << " name=" << (d->name); }  break;
        case ASSIGN__CALCULATED_NAME_1__TYPE_0__NEED_VERIFICATION_1: os << "ASSIGN__CALCULATED_NAME_1__TYPE_0__NEED_VERIFICATION_1"; { const Tok::Assign *d = reinterpret_cast<const Tok::Assign *>( tok ); os << " static=" << bool(d->attributes&1); os << " const=" << bool(d->attributes&2); os << " virtual=" << bool(d->attributes&4); os << " want_ref=" << bool(d->attributes&8); os << " property=" << bool(d->attributes&16); os << " offset_to_doc=" << (d->offset_to_doc); os << " name=" << (d->name); }  break;
        case ASSIGN__CALCULATED_NAME_0__TYPE_1__NEED_VERIFICATION_1: os << "ASSIGN__CALCULATED_NAME_0__TYPE_1__NEED_VERIFICATION_1"; { const Tok::Assign *d = reinterpret_cast<const Tok::Assign *>( tok ); os << " static=" << bool(d->attributes&1); os << " const=" << bool(d->attributes&2); os << " virtual=" << bool(d->attributes&4); os << " want_ref=" << bool(d->attributes&8); os << " property=" << bool(d->attributes&16); os << " offset_to_doc=" << (d->offset_to_doc); os << " name=" << (d->name); }  break;
        case ASSIGN__CALCULATED_NAME_1__TYPE_1__NEED_VERIFICATION_1: os << "ASSIGN__CALCULATED_NAME_1__TYPE_1__NEED_VERIFICATION_1"; { const Tok::Assign *d = reinterpret_cast<const Tok::Assign *>( tok ); os << " static=" << bool(d->attributes&1); os << " const=" << bool(d->attributes&2); os << " virtual=" << bool(d->attributes&4); os << " want_ref=" << bool(d->attributes&8); os << " property=" << bool(d->attributes&16); os << " offset_to_doc=" << (d->offset_to_doc); os << " name=" << (d->name); }  break;
        case APPLY: os << "APPLY"; { const Tok::Apply *d = reinterpret_cast<const Tok::Apply *>( tok ); os << " expect_res=" << bool(d->attributes&1); os << " nb_unnamed=" << (d->nb_unnamed); os << " named="; for(unsigned i=0;i<d->nb_named;++i) os << (d->get_first_named()[i]) << ' '; }  break;
        case SELECT: os << "SELECT"; { const Tok::Select *d = reinterpret_cast<const Tok::Select *>( tok ); os << " expect_res=" << bool(d->attributes&1); os << " nb_unnamed=" << (d->nb_unnamed); os << " named="; for(unsigned i=0;i<d->nb_named;++i) os << (d->get_first_named()[i]) << ' '; }  break;
        case CHANGE_BEHAVIOR: os << "CHANGE_BEHAVIOR"; { const Tok::Change_behavior *d = reinterpret_cast<const Tok::Change_behavior *>( tok ); os << " expect_res=" << bool(d->attributes&1); os << " nb_unnamed=" << (d->nb_unnamed); os << " named="; for(unsigned i=0;i<d->nb_named;++i) os << (d->get_first_named()[i]) << ' '; }  break;
        case PARTIAL_INSTANCIATION: os << "PARTIAL_INSTANCIATION"; break;
        case APPEND_INHERITANCE_DATA: os << "APPEND_INHERITANCE_DATA"; break;
        case TEST_NEXT_TYPE: os << "TEST_NEXT_TYPE"; break;
        case PASS: os << "PASS"; break;
        case IMPORT: os << "IMPORT"; break;
        case EXEC: os << "EXEC"; break;
        case THROW: os << "THROW"; break;
        case TRY: os << "TRY"; { const Tok::Try *d = reinterpret_cast<const Tok::Try *>( tok ); os << " offset_to_next_inst=" << (int *)((const char *)tok + d->offset_to_next_inst); }  break;
        case CATCH: os << "CATCH"; { const Tok::Catch *d = reinterpret_cast<const Tok::Catch *>( tok ); os << " arg=" << (d->arg); os << " offset_to_next_inst=" << (int *)((const char *)tok + d->offset_to_next_inst); }  break;
        case END_CATCH_BLOCK: os << "END_CATCH_BLOCK"; break;
        case END_TRY_EXCEPTION_BLOCK: os << "END_TRY_EXCEPTION_BLOCK"; break;
        case GET_CALCULATED_ATTR: os << "GET_CALCULATED_ATTR"; break;
        case GET_VALUE_PROP: os << "GET_VALUE_PROP"; break;
        case NUMBER: os << "NUMBER"; { const Tok::Number *d = reinterpret_cast<const Tok::Number *>( tok ); os << " unsigned=" << bool(d->attributes&1); os << " imaginary=" << bool(d->attributes&2); os << " expo=" << (d->expo); os << " values="; for(unsigned i=0;i<d->nb_values;++i) os << (d->get_first_values()[i]) << ' '; }  break;
        case NUMBER_INT32: os << "NUMBER_INT32"; { const Tok::Number_int32 *d = reinterpret_cast<const Tok::Number_int32 *>( tok ); os << " val=" << (d->val); }  break;
        case NUMBER_UNSIGNED32: os << "NUMBER_UNSIGNED32"; { const Tok::Number_unsigned32 *d = reinterpret_cast<const Tok::Number_unsigned32 *>( tok ); os << " val=" << (d->val); }  break;
        case STRING: os << "STRING"; { const Tok::String *d = reinterpret_cast<const Tok::String *>( tok ); os << " characters="; for(unsigned i=0;i<d->nb_characters;++i) os << (d->get_first_characters()[i]); }  break;
        case AND_OR_OR__WANT_OR_0: os << "AND_OR_OR__WANT_OR_0"; { const Tok::And_or_or *d = reinterpret_cast<const Tok::And_or_or *>( tok ); os << " offset_if_dont_want_to_continue=" << (int *)((const char *)tok + d->offset_if_dont_want_to_continue); }  break;
        case AND_OR_OR__WANT_OR_1: os << "AND_OR_OR__WANT_OR_1"; { const Tok::And_or_or *d = reinterpret_cast<const Tok::And_or_or *>( tok ); os << " offset_if_dont_want_to_continue=" << (int *)((const char *)tok + d->offset_if_dont_want_to_continue); }  break;
        case CONVERSION_TO_BOOL: os << "CONVERSION_TO_BOOL"; break;
        case IF_OR_WHILE__WANT_WHILE_0: os << "IF_OR_WHILE__WANT_WHILE_0"; { const Tok::If_or_while *d = reinterpret_cast<const Tok::If_or_while *>( tok ); os << " offset_if_fail=" << (int *)((const char *)tok + d->offset_if_fail); os << " offset_if_not_executed=" << (int *)((const char *)tok + d->offset_if_not_executed); }  break;
        case IF_OR_WHILE__WANT_WHILE_1: os << "IF_OR_WHILE__WANT_WHILE_1"; { const Tok::If_or_while *d = reinterpret_cast<const Tok::If_or_while *>( tok ); os << " offset_if_fail=" << (int *)((const char *)tok + d->offset_if_fail); os << " offset_if_not_executed=" << (int *)((const char *)tok + d->offset_if_not_executed); }  break;
        case END_OF_AN_IF_BLOCK: os << "END_OF_AN_IF_BLOCK"; break;
        case END_OF_A_WHILE_BLOCK__IN_ELSE_BLOCK_0: os << "END_OF_A_WHILE_BLOCK__IN_ELSE_BLOCK_0"; { const Tok::End_of_a_while_block *d = reinterpret_cast<const Tok::End_of_a_while_block *>( tok ); os << " offset_to_condition=" << (int *)((const char *)tok + d->offset_to_condition); }  break;
        case END_OF_A_WHILE_BLOCK__IN_ELSE_BLOCK_1: os << "END_OF_A_WHILE_BLOCK__IN_ELSE_BLOCK_1"; { const Tok::End_of_a_while_block *d = reinterpret_cast<const Tok::End_of_a_while_block *>( tok ); os << " offset_to_condition=" << (int *)((const char *)tok + d->offset_to_condition); }  break;
        case END_OF_AN_IF_BLOCK_FOLLOWED_BY_AN_ELSE: os << "END_OF_AN_IF_BLOCK_FOLLOWED_BY_AN_ELSE"; { const Tok::End_of_an_if_block_followed_by_an_else *d = reinterpret_cast<const Tok::End_of_an_if_block_followed_by_an_else *>( tok ); os << " offset_to_next_inst=" << (int *)((const char *)tok + d->offset_to_next_inst); }  break;
        case END_OF_A_WHILE_BLOCK_FOLLOWED_BY_AN_ELSE: os << "END_OF_A_WHILE_BLOCK_FOLLOWED_BY_AN_ELSE"; { const Tok::End_of_a_while_block_followed_by_an_else *d = reinterpret_cast<const Tok::End_of_a_while_block_followed_by_an_else *>( tok ); os << " offset_to_condition=" << (int *)((const char *)tok + d->offset_to_condition); os << " offset_to_next_inst=" << (int *)((const char *)tok + d->offset_to_next_inst); }  break;
        case FOR__WANT_TUPLE_0: os << "FOR__WANT_TUPLE_0"; { const Tok::For *d = reinterpret_cast<const Tok::For *>( tok ); os << " offset_to_next_inst=" << (int *)((const char *)tok + d->offset_to_next_inst); os << " names="; for(unsigned i=0;i<d->nb_names;++i) os << (d->get_first_names()[i]) << ' '; }  break;
        case FOR__WANT_TUPLE_1: os << "FOR__WANT_TUPLE_1"; { const Tok::For *d = reinterpret_cast<const Tok::For *>( tok ); os << " offset_to_next_inst=" << (int *)((const char *)tok + d->offset_to_next_inst); os << " names="; for(unsigned i=0;i<d->nb_names;++i) os << (d->get_first_names()[i]) << ' '; }  break;
        case END_OF_A_FOR_BLOCK: os << "END_OF_A_FOR_BLOCK"; break;
        case LAMBDA: os << "LAMBDA"; { const Tok::Lambda *d = reinterpret_cast<const Tok::Lambda *>( tok ); os << " offset_to_next_inst=" << (int *)((const char *)tok + d->offset_to_next_inst); os << " arguments="; for(unsigned i=0;i<d->nb_arguments;++i) os << (d->get_first_arguments()[i]) << ' '; }  break;
        case LABEL: os << "LABEL"; { const Tok::Label *d = reinterpret_cast<const Tok::Label *>( tok ); os << " offset_to_next_inst=" << (int *)((const char *)tok + d->offset_to_next_inst); os << " name=" << (d->name); }  break;
        case END_OF_A_LABEL_BLOCK: os << "END_OF_A_LABEL_BLOCK"; break;
        case DEF_RETURN: os << "DEF_RETURN"; break;
        case BREAK_OR_CONTINUE__WANT_CONTINUE_0: os << "BREAK_OR_CONTINUE__WANT_CONTINUE_0"; break;
        case BREAK_OR_CONTINUE__WANT_CONTINUE_1: os << "BREAK_OR_CONTINUE__WANT_CONTINUE_1"; break;
        case MAKE_VARARGS__EXPECT_RESULT_0: os << "MAKE_VARARGS__EXPECT_RESULT_0"; { const Tok::Make_varargs *d = reinterpret_cast<const Tok::Make_varargs *>( tok ); os << " nb_unnamed_children=" << (d->nb_unnamed_children); os << " names="; for(unsigned i=0;i<d->nb_names;++i) os << (d->get_first_names()[i]) << ' '; }  break;
        case MAKE_VARARGS__EXPECT_RESULT_1: os << "MAKE_VARARGS__EXPECT_RESULT_1"; { const Tok::Make_varargs *d = reinterpret_cast<const Tok::Make_varargs *>( tok ); os << " nb_unnamed_children=" << (d->nb_unnamed_children); os << " names="; for(unsigned i=0;i<d->nb_names;++i) os << (d->get_first_names()[i]) << ' '; }  break;
        case DEFINITION: os << "DEFINITION"; { const Tok::Definition *d = reinterpret_cast<const Tok::Definition *>( tok ); os << " class=" << bool(d->attributes&1); os << " static=" << bool(d->attributes&2); os << " virtual=" << bool(d->attributes&4); os << " varargs=" << bool(d->attributes&8); os << " self_as_arg=" << bool(d->attributes&16); os << " abstract=" << bool(d->attributes&32); os << " method=" << bool(d->attributes&64); os << " name=" << (d->name); os << " offset_to_doc=" << (d->offset_to_doc); os << " size_needed_in_stack=" << (d->size_needed_in_stack); os << " pertinence=" << (d->pertinence); os << " min_nb_args=" << (d->min_nb_args); os << " property_name=" << (d->property_name); os << " type_property=" << (d->type_property); os << " offset_to_try_block=" << (int *)((const char *)tok + d->offset_to_try_block); os << " offset_to_block=" << (int *)((const char *)tok + d->offset_to_block); os << " offset_to_next_inst=" << (int *)((const char *)tok + d->offset_to_next_inst); os << " args="; for(unsigned i=0;i<d->nb_args;++i) os << (d->get_first_args()[i]) << ' '; }  break;
        case PROPOSITION_OF_DEFAULT_VALUE: os << "PROPOSITION_OF_DEFAULT_VALUE"; { const Tok::Proposition_of_default_value *d = reinterpret_cast<const Tok::Proposition_of_default_value *>( tok ); os << " num_arg=" << (d->num_arg); os << " offset_to_next_inst=" << (int *)((const char *)tok + d->offset_to_next_inst); }  break;
        case ASSIGN_TO_ARG_NB: os << "ASSIGN_TO_ARG_NB"; { const Tok::Assign_to_arg_nb *d = reinterpret_cast<const Tok::Assign_to_arg_nb *>( tok ); os << " num_arg=" << (d->num_arg); }  break;
        case END_CLASS_BLOCK: os << "END_CLASS_BLOCK"; break;
        case END_DEF_BLOCK: os << "END_DEF_BLOCK"; break;
        case END_TRY_BLOCK: os << "END_TRY_BLOCK"; break;
        case CONDITION_IN_TRY_BLOCK: os << "CONDITION_IN_TRY_BLOCK"; break;
        case PERTINENCE_IN_TRY_BLOCK: os << "PERTINENCE_IN_TRY_BLOCK"; break;
        case EXEC_IN_PREV_SCOPE: os << "EXEC_IN_PREV_SCOPE"; break;
        case END_EXEC_IN_PREV_SCOPE: os << "END_EXEC_IN_PREV_SCOPE"; break;
    }
}

const void *get_next(const void *tok) {
    switch ( *reinterpret_cast<const unsigned *>(tok) ) {
        case END_TOK_FILE: return reinterpret_cast<const End_tok_file *>( tok )->next();
        case PUSH_ROOM_FOR_NEW_VARIABLE: return reinterpret_cast<const Push_room_for_new_variable *>( tok )->next();
        case CHECK_ROOM_IN_VARIABLE_STACK: return reinterpret_cast<const Check_room_in_variable_stack *>( tok )->next();
        case VARIABLE_NAMED: return reinterpret_cast<const Variable_named *>( tok )->next();
        case VARIABLE_IN_STACK: return reinterpret_cast<const Variable_in_stack *>( tok )->next();
        case VARIABLE_IN_ARGS: return reinterpret_cast<const Variable_in_args *>( tok )->next();
        case GET_ATTR: return reinterpret_cast<const Get_attr *>( tok )->next();
        case SELF: return reinterpret_cast<const Self *>( tok )->next();
        case INTERACT: return reinterpret_cast<const Interact *>( tok )->next();
        case CONSTIFY: return reinterpret_cast<const Constify *>( tok )->next();
        case ASSIGN__CALCULATED_NAME_0__TYPE_0__NEED_VERIFICATION_0: return reinterpret_cast<const Assign *>( tok )->next();
        case ASSIGN__CALCULATED_NAME_1__TYPE_0__NEED_VERIFICATION_0: return reinterpret_cast<const Assign *>( tok )->next();
        case ASSIGN__CALCULATED_NAME_0__TYPE_1__NEED_VERIFICATION_0: return reinterpret_cast<const Assign *>( tok )->next();
        case ASSIGN__CALCULATED_NAME_1__TYPE_1__NEED_VERIFICATION_0: return reinterpret_cast<const Assign *>( tok )->next();
        case ASSIGN__CALCULATED_NAME_0__TYPE_0__NEED_VERIFICATION_1: return reinterpret_cast<const Assign *>( tok )->next();
        case ASSIGN__CALCULATED_NAME_1__TYPE_0__NEED_VERIFICATION_1: return reinterpret_cast<const Assign *>( tok )->next();
        case ASSIGN__CALCULATED_NAME_0__TYPE_1__NEED_VERIFICATION_1: return reinterpret_cast<const Assign *>( tok )->next();
        case ASSIGN__CALCULATED_NAME_1__TYPE_1__NEED_VERIFICATION_1: return reinterpret_cast<const Assign *>( tok )->next();
        case APPLY: return reinterpret_cast<const Apply *>( tok )->next();
        case SELECT: return reinterpret_cast<const Select *>( tok )->next();
        case CHANGE_BEHAVIOR: return reinterpret_cast<const Change_behavior *>( tok )->next();
        case PARTIAL_INSTANCIATION: return reinterpret_cast<const Partial_instanciation *>( tok )->next();
        case APPEND_INHERITANCE_DATA: return reinterpret_cast<const Append_inheritance_data *>( tok )->next();
        case TEST_NEXT_TYPE: return reinterpret_cast<const Test_next_type *>( tok )->next();
        case PASS: return reinterpret_cast<const Pass *>( tok )->next();
        case IMPORT: return reinterpret_cast<const Import *>( tok )->next();
        case EXEC: return reinterpret_cast<const Exec *>( tok )->next();
        case THROW: return reinterpret_cast<const Throw *>( tok )->next();
        case TRY: return reinterpret_cast<const Try *>( tok )->next();
        case CATCH: return reinterpret_cast<const Catch *>( tok )->next();
        case END_CATCH_BLOCK: return reinterpret_cast<const End_catch_block *>( tok )->next();
        case END_TRY_EXCEPTION_BLOCK: return reinterpret_cast<const End_try_exception_block *>( tok )->next();
        case GET_CALCULATED_ATTR: return reinterpret_cast<const Get_calculated_attr *>( tok )->next();
        case GET_VALUE_PROP: return reinterpret_cast<const Get_value_prop *>( tok )->next();
        case NUMBER: return reinterpret_cast<const Number *>( tok )->next();
        case NUMBER_INT32: return reinterpret_cast<const Number_int32 *>( tok )->next();
        case NUMBER_UNSIGNED32: return reinterpret_cast<const Number_unsigned32 *>( tok )->next();
        case STRING: return reinterpret_cast<const String *>( tok )->next();
        case AND_OR_OR__WANT_OR_0: return reinterpret_cast<const And_or_or *>( tok )->next();
        case AND_OR_OR__WANT_OR_1: return reinterpret_cast<const And_or_or *>( tok )->next();
        case CONVERSION_TO_BOOL: return reinterpret_cast<const Conversion_to_bool *>( tok )->next();
        case IF_OR_WHILE__WANT_WHILE_0: return reinterpret_cast<const If_or_while *>( tok )->next();
        case IF_OR_WHILE__WANT_WHILE_1: return reinterpret_cast<const If_or_while *>( tok )->next();
        case END_OF_AN_IF_BLOCK: return reinterpret_cast<const End_of_an_if_block *>( tok )->next();
        case END_OF_A_WHILE_BLOCK__IN_ELSE_BLOCK_0: return reinterpret_cast<const End_of_a_while_block *>( tok )->next();
        case END_OF_A_WHILE_BLOCK__IN_ELSE_BLOCK_1: return reinterpret_cast<const End_of_a_while_block *>( tok )->next();
        case END_OF_AN_IF_BLOCK_FOLLOWED_BY_AN_ELSE: return reinterpret_cast<const End_of_an_if_block_followed_by_an_else *>( tok )->next();
        case END_OF_A_WHILE_BLOCK_FOLLOWED_BY_AN_ELSE: return reinterpret_cast<const End_of_a_while_block_followed_by_an_else *>( tok )->next();
        case FOR__WANT_TUPLE_0: return reinterpret_cast<const For *>( tok )->next();
        case FOR__WANT_TUPLE_1: return reinterpret_cast<const For *>( tok )->next();
        case END_OF_A_FOR_BLOCK: return reinterpret_cast<const End_of_a_for_block *>( tok )->next();
        case LAMBDA: return reinterpret_cast<const Lambda *>( tok )->next();
        case LABEL: return reinterpret_cast<const Label *>( tok )->next();
        case END_OF_A_LABEL_BLOCK: return reinterpret_cast<const End_of_a_label_block *>( tok )->next();
        case DEF_RETURN: return reinterpret_cast<const Def_return *>( tok )->next();
        case BREAK_OR_CONTINUE__WANT_CONTINUE_0: return reinterpret_cast<const Break_or_continue *>( tok )->next();
        case BREAK_OR_CONTINUE__WANT_CONTINUE_1: return reinterpret_cast<const Break_or_continue *>( tok )->next();
        case MAKE_VARARGS__EXPECT_RESULT_0: return reinterpret_cast<const Make_varargs *>( tok )->next();
        case MAKE_VARARGS__EXPECT_RESULT_1: return reinterpret_cast<const Make_varargs *>( tok )->next();
        case DEFINITION: return reinterpret_cast<const Definition *>( tok )->next();
        case PROPOSITION_OF_DEFAULT_VALUE: return reinterpret_cast<const Proposition_of_default_value *>( tok )->next();
        case ASSIGN_TO_ARG_NB: return reinterpret_cast<const Assign_to_arg_nb *>( tok )->next();
        case END_CLASS_BLOCK: return reinterpret_cast<const End_class_block *>( tok )->next();
        case END_DEF_BLOCK: return reinterpret_cast<const End_def_block *>( tok )->next();
        case END_TRY_BLOCK: return reinterpret_cast<const End_try_block *>( tok )->next();
        case CONDITION_IN_TRY_BLOCK: return reinterpret_cast<const Condition_in_try_block *>( tok )->next();
        case PERTINENCE_IN_TRY_BLOCK: return reinterpret_cast<const Pertinence_in_try_block *>( tok )->next();
        case EXEC_IN_PREV_SCOPE: return reinterpret_cast<const Exec_in_prev_scope *>( tok )->next();
        case END_EXEC_IN_PREV_SCOPE: return reinterpret_cast<const End_exec_in_prev_scope *>( tok )->next();
    }
    return NULL;
}
const void *get_next_in_exception_mode(const void *tok) {
    switch ( *reinterpret_cast<const unsigned *>(tok) ) {
        case END_TOK_FILE: return reinterpret_cast<const End_tok_file *>( tok )->next_in_exception_mode();
        case PUSH_ROOM_FOR_NEW_VARIABLE: return reinterpret_cast<const Push_room_for_new_variable *>( tok )->next_in_exception_mode();
        case CHECK_ROOM_IN_VARIABLE_STACK: return reinterpret_cast<const Check_room_in_variable_stack *>( tok )->next_in_exception_mode();
        case VARIABLE_NAMED: return reinterpret_cast<const Variable_named *>( tok )->next_in_exception_mode();
        case VARIABLE_IN_STACK: return reinterpret_cast<const Variable_in_stack *>( tok )->next_in_exception_mode();
        case VARIABLE_IN_ARGS: return reinterpret_cast<const Variable_in_args *>( tok )->next_in_exception_mode();
        case GET_ATTR: return reinterpret_cast<const Get_attr *>( tok )->next_in_exception_mode();
        case SELF: return reinterpret_cast<const Self *>( tok )->next_in_exception_mode();
        case INTERACT: return reinterpret_cast<const Interact *>( tok )->next_in_exception_mode();
        case CONSTIFY: return reinterpret_cast<const Constify *>( tok )->next_in_exception_mode();
        case ASSIGN__CALCULATED_NAME_0__TYPE_0__NEED_VERIFICATION_0: return reinterpret_cast<const Assign *>( tok )->next_in_exception_mode();
        case ASSIGN__CALCULATED_NAME_1__TYPE_0__NEED_VERIFICATION_0: return reinterpret_cast<const Assign *>( tok )->next_in_exception_mode();
        case ASSIGN__CALCULATED_NAME_0__TYPE_1__NEED_VERIFICATION_0: return reinterpret_cast<const Assign *>( tok )->next_in_exception_mode();
        case ASSIGN__CALCULATED_NAME_1__TYPE_1__NEED_VERIFICATION_0: return reinterpret_cast<const Assign *>( tok )->next_in_exception_mode();
        case ASSIGN__CALCULATED_NAME_0__TYPE_0__NEED_VERIFICATION_1: return reinterpret_cast<const Assign *>( tok )->next_in_exception_mode();
        case ASSIGN__CALCULATED_NAME_1__TYPE_0__NEED_VERIFICATION_1: return reinterpret_cast<const Assign *>( tok )->next_in_exception_mode();
        case ASSIGN__CALCULATED_NAME_0__TYPE_1__NEED_VERIFICATION_1: return reinterpret_cast<const Assign *>( tok )->next_in_exception_mode();
        case ASSIGN__CALCULATED_NAME_1__TYPE_1__NEED_VERIFICATION_1: return reinterpret_cast<const Assign *>( tok )->next_in_exception_mode();
        case APPLY: return reinterpret_cast<const Apply *>( tok )->next_in_exception_mode();
        case SELECT: return reinterpret_cast<const Select *>( tok )->next_in_exception_mode();
        case CHANGE_BEHAVIOR: return reinterpret_cast<const Change_behavior *>( tok )->next_in_exception_mode();
        case PARTIAL_INSTANCIATION: return reinterpret_cast<const Partial_instanciation *>( tok )->next_in_exception_mode();
        case APPEND_INHERITANCE_DATA: return reinterpret_cast<const Append_inheritance_data *>( tok )->next_in_exception_mode();
        case TEST_NEXT_TYPE: return reinterpret_cast<const Test_next_type *>( tok )->next_in_exception_mode();
        case PASS: return reinterpret_cast<const Pass *>( tok )->next_in_exception_mode();
        case IMPORT: return reinterpret_cast<const Import *>( tok )->next_in_exception_mode();
        case EXEC: return reinterpret_cast<const Exec *>( tok )->next_in_exception_mode();
        case THROW: return reinterpret_cast<const Throw *>( tok )->next_in_exception_mode();
        case TRY: return reinterpret_cast<const Try *>( tok )->next_in_exception_mode();
        case CATCH: return reinterpret_cast<const Catch *>( tok )->next_in_exception_mode();
        case END_CATCH_BLOCK: return reinterpret_cast<const End_catch_block *>( tok )->next_in_exception_mode();
        case END_TRY_EXCEPTION_BLOCK: return reinterpret_cast<const End_try_exception_block *>( tok )->next_in_exception_mode();
        case GET_CALCULATED_ATTR: return reinterpret_cast<const Get_calculated_attr *>( tok )->next_in_exception_mode();
        case GET_VALUE_PROP: return reinterpret_cast<const Get_value_prop *>( tok )->next_in_exception_mode();
        case NUMBER: return reinterpret_cast<const Number *>( tok )->next_in_exception_mode();
        case NUMBER_INT32: return reinterpret_cast<const Number_int32 *>( tok )->next_in_exception_mode();
        case NUMBER_UNSIGNED32: return reinterpret_cast<const Number_unsigned32 *>( tok )->next_in_exception_mode();
        case STRING: return reinterpret_cast<const String *>( tok )->next_in_exception_mode();
        case AND_OR_OR__WANT_OR_0: return reinterpret_cast<const And_or_or *>( tok )->next_in_exception_mode();
        case AND_OR_OR__WANT_OR_1: return reinterpret_cast<const And_or_or *>( tok )->next_in_exception_mode();
        case CONVERSION_TO_BOOL: return reinterpret_cast<const Conversion_to_bool *>( tok )->next_in_exception_mode();
        case IF_OR_WHILE__WANT_WHILE_0: return reinterpret_cast<const If_or_while *>( tok )->next_in_exception_mode();
        case IF_OR_WHILE__WANT_WHILE_1: return reinterpret_cast<const If_or_while *>( tok )->next_in_exception_mode();
        case END_OF_AN_IF_BLOCK: return reinterpret_cast<const End_of_an_if_block *>( tok )->next_in_exception_mode();
        case END_OF_A_WHILE_BLOCK__IN_ELSE_BLOCK_0: return reinterpret_cast<const End_of_a_while_block *>( tok )->next_in_exception_mode();
        case END_OF_A_WHILE_BLOCK__IN_ELSE_BLOCK_1: return reinterpret_cast<const End_of_a_while_block *>( tok )->next_in_exception_mode();
        case END_OF_AN_IF_BLOCK_FOLLOWED_BY_AN_ELSE: return reinterpret_cast<const End_of_an_if_block_followed_by_an_else *>( tok )->next_in_exception_mode();
        case END_OF_A_WHILE_BLOCK_FOLLOWED_BY_AN_ELSE: return reinterpret_cast<const End_of_a_while_block_followed_by_an_else *>( tok )->next_in_exception_mode();
        case FOR__WANT_TUPLE_0: return reinterpret_cast<const For *>( tok )->next_in_exception_mode();
        case FOR__WANT_TUPLE_1: return reinterpret_cast<const For *>( tok )->next_in_exception_mode();
        case END_OF_A_FOR_BLOCK: return reinterpret_cast<const End_of_a_for_block *>( tok )->next_in_exception_mode();
        case LAMBDA: return reinterpret_cast<const Lambda *>( tok )->next_in_exception_mode();
        case LABEL: return reinterpret_cast<const Label *>( tok )->next_in_exception_mode();
        case END_OF_A_LABEL_BLOCK: return reinterpret_cast<const End_of_a_label_block *>( tok )->next_in_exception_mode();
        case DEF_RETURN: return reinterpret_cast<const Def_return *>( tok )->next_in_exception_mode();
        case BREAK_OR_CONTINUE__WANT_CONTINUE_0: return reinterpret_cast<const Break_or_continue *>( tok )->next_in_exception_mode();
        case BREAK_OR_CONTINUE__WANT_CONTINUE_1: return reinterpret_cast<const Break_or_continue *>( tok )->next_in_exception_mode();
        case MAKE_VARARGS__EXPECT_RESULT_0: return reinterpret_cast<const Make_varargs *>( tok )->next_in_exception_mode();
        case MAKE_VARARGS__EXPECT_RESULT_1: return reinterpret_cast<const Make_varargs *>( tok )->next_in_exception_mode();
        case DEFINITION: return reinterpret_cast<const Definition *>( tok )->next_in_exception_mode();
        case PROPOSITION_OF_DEFAULT_VALUE: return reinterpret_cast<const Proposition_of_default_value *>( tok )->next_in_exception_mode();
        case ASSIGN_TO_ARG_NB: return reinterpret_cast<const Assign_to_arg_nb *>( tok )->next_in_exception_mode();
        case END_CLASS_BLOCK: return reinterpret_cast<const End_class_block *>( tok )->next_in_exception_mode();
        case END_DEF_BLOCK: return reinterpret_cast<const End_def_block *>( tok )->next_in_exception_mode();
        case END_TRY_BLOCK: return reinterpret_cast<const End_try_block *>( tok )->next_in_exception_mode();
        case CONDITION_IN_TRY_BLOCK: return reinterpret_cast<const Condition_in_try_block *>( tok )->next_in_exception_mode();
        case PERTINENCE_IN_TRY_BLOCK: return reinterpret_cast<const Pertinence_in_try_block *>( tok )->next_in_exception_mode();
        case EXEC_IN_PREV_SCOPE: return reinterpret_cast<const Exec_in_prev_scope *>( tok )->next_in_exception_mode();
        case END_EXEC_IN_PREV_SCOPE: return reinterpret_cast<const End_exec_in_prev_scope *>( tok )->next_in_exception_mode();
    }
    return NULL;
}
} // namespace Tok
