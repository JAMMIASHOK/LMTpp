#ifndef OP_H
#define OP_H

/*
 bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla

*/


/*
class A {

}

static const int static_size = -1; double x ; //;

struct B {}
*/

//T val[ order ];

//static int main  () const { }
template<class TO,int static_size,class IVO> Vec<T> operator()(const Vec<TO,static_size,IVO> &x = 0 , double z = 1. ) const {}
//int t ;

/*
template<unsigned order,class T=double>
class PolApprox {
    PolApprox( const T &v = 0.0 ) {
        val[0] = v;
        for(unsigned i=1;i<order;++i)
            val[i] = T(0.0);
    }
    T operator[](const T &x) const {
        T res = val[0];
        T m = x;
        for( unsigned i=1; i<order; ++i, m *= x )
            res += val[i] * m;
        return res;
    }
    template<class TO,int static_size,class IVO> Vec<T> operator()(const Vec<TO,static_size,IVO> &x) const {
        Vec<T> res;
        for(unsigned i=0;i<x.size();++i)
            res.push_back( operator[](x[i]) );
        return res;
    }
    
    T get_max_coeff() {
        T res = val[0];
        for(unsigned i=1;i<order;++i)
            if ( LMT::abs( val[i] ) > LMT::abs( res ) )
                res = val[i];
        return res;
    }
    
    void shift_coeffs() {
        for(unsigned i=0;i<order-1;++i)
            val[i] = val[i+1];
        val[order-1] = T(0);
    }
    
    PolApprox &operator+=(const PolApprox &p) { *this = *this + p; return *this; }
    PolApprox &operator-=(const PolApprox &p) { *this = *this - p; return *this; }
    PolApprox &operator*=(const PolApprox &p) { *this = *this * p; return *this; }
    PolApprox &operator/=(const PolApprox &p) { *this = *this / p; return *this; }
    
    T val[ order ];
};
*/


/*!
template<unsigned order,class T>
std::ostream &operator<<(std::ostream &os,const PolApprox<order,T> &p) const titi {  bla bla bla { bla bla bla }  bla bla } 
*/
//template<class TV,bool with_simd> IncrementalAccess<TV,true ,with_simd> getIncrementalAccess(const TV *v,int x, double y = 0., double z ) { return v; }

/*!
template<class TT,int s> SimdVec<typename Vec<TT,s>::template SubType<0>::T,1> get_simd(const Vec<TT,s> &v,unsigned i,const Number<1> &) {
        return SimdVec<typename Vec<TT,s>::template SubType<0>::T,1>( v[i+0] );
    }
*/

/*!

 bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob bob

*/

//static const int static_size = -1; double x ; ;
//incrementalAccess(const TV &vv) { v.val = &vv; }  /*!     commmmmmmmmmmmmmmmmmmmmm */
//static const int englobing = 10 + TypeInformation<ST>::englobing;