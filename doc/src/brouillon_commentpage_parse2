
    char str[LENGTH_STRING] ;
    string localstring ;
    string localcode ;
    string string_a_analyser ;
    int i,pos,l,n,start,pos2,m ;
    char file[LENGTH_NAME_FILE] ;
    char* pc ;
    char* pc2 ;
    bool lireOuPas ;
    char delimitateurDeFin,c ;
    Comment* ptr_comment ;
    vector<string> commentaire ;
    //FILE* pf ;

 
    string2chaine( file,LENGTH_NAME_FILE,nameFile ) ;
    ifstream entree( file , ios::in ) ;

    if (! entree) {
        cerr << " impossible d' ouvrir le fichier "  << file << " pour PageComment :: parse() " << endl ;
        return ;
    }

    lireOuPas = true ;

    while ( true ) { // boucle sur la lecture de lignes
        if (lireOuPas) entree.getline( str,LENGTH_STRING ) ; // problème si la ligne lue a une taille supérieure à LENGTH_STRING
        lireOuPas = true ;
        //cout << "---- bouillot" << endl ;
        n = entree.gcount() ;
        if ( n==0 ) {
            commentaire.clear() ;// on sort de la méthode puisqu'il n' y a plus de ligne
            break ;
        }
        if (chercher_motif( str,"//",&pos )) { // c'est un commentaire de "fin de ligne" donc on ne garde que le début 
            localcode.push_back( ' ' ) ;
            //for(i=0;i<pos;i++) localcode.push_back( str[i] ) ;
            str[pos] = '\0' ;
            lireOuPas = false ; // car il n'a pas fini cette ligne : il manque le début
            continue ;
        }
        if (chercher_motif( str,"/*",&pos )) {
            localcode.push_back( ' ' ) ;
            // on récupère le code situé avant le /*
            for(i=0;i<pos;i++) localcode.push_back( str[i] ) ;
            // ON PARSE ICI LE CODE contenu dans le string localcode !!!!!!!!!!!!!
            cout << "localcode = |||" << localcode << "|||" << endl ;
            localcode.clear() ;
            if (str[pos+2] == '!') { // c'est un bon commentaire. un vrai de vrai
                commentaire.clear() ;
                // on regarde ce qui vient après /*!
                if (chercher_motif( str,"*/",&pos2,pos+3 )) {
                
                    pos += 2 ;
                    m = pos2 - pos ; 
                    for(i=0;i<m;i++) localstring[i] = str[i+pos] ;
                    // on copie la chaine de str+pos vers str .... au boulôt
                
                } else {
                    localstring = str + pos + 3 ;
                    commentaire.push_back( localstring ) ;
                    while ( true ) {
                        entree.getline( str,LENGTH_STRING ) ;
                        n = entree.gcount() ;
                        if ( n==0 ) { 
                            commentaire.clear() ;
                            return ; // -----> SORTIE ANORMALE
                        }
                        if (chercher_motif( str,"*/",&pos )) {
                            //CodeIsParsing = false ;
                            for(i=0;i<pos;i++) localstring[i] = str[i] ;
                            commentaire.push_back( localstring ) ;
                            pos += 2 ; // c'est le début d'un nouveau code... Ah!
                            i = 0 ;
                            while (c = str[i+pos]) {
                                str[i] = c ;
                                i++ ;
                            }
                            str[i] = '\0' ;
                            lireOuPas = false ;
                            break ;
                        } else
                            commentaire.push_back( localstring ) ;
                    }
                }
                // ON PARSE LE COMMENTAIRE (pour le code voir le brouillon)
                cout << " commentaire à parser" << endl ;
                for(i=0;i<commentaire.size();i++)
                    cout << "__|" << commentaire[i] << "|__" << endl ;
            } else { // c'est un commentaire doxygen ou un commentaire standard : on passe
                while ( true ) {
                    entree.getline( str,LENGTH_STRING ) ;
                    if ( n==0 ) {
                        commentaire.clear() ;
                        return ; // -----> SORTIE ANORMALE
                    }
                    if (chercher_motif( str,"*/",&pos )) {
                        pos += 2 ; // c'est le début d'un nouveau code... Ah!
                        i = 0 ;
                        while (c = str[i+pos]) {
                            str[i] = c ;
                            i++ ;
                        }
                        str[i] = '\0' ;
                        lireOuPas = false ;
                        break ;
                    } 
                }
            }
        } else {
            localcode.push_back( ' ' ) ;
            localcode += str ;  //on ajoute le code à la suite
        }

    }

    cout << "localcode de fin = |||" << localcode << "|||" << endl ;
 